<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Zman</title>
    
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon.png">
    <meta name="theme-color" content="#FFCDD2">
    
    <style>
        /* === GLOBAL APP STYLES === */
        html, body {
            margin: 0; padding: 0; width: 100vw; height: 100dvh; 
            overflow: hidden; touch-action: none; position: fixed; 
            background-color: #FFCDD2; 
            color: #FFFFFF; font-family: sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-sizing: border-box; 
            transition: background-color 1.5s ease-in-out; 
            user-select: none; -webkit-user-select: none;
        }

        #app-switcher {
            position: absolute; top: 40px; z-index: 100;
            background: rgba(255, 255, 255, 0.15); border-radius: 20px;
            display: flex; padding: 4px; gap: 4px;
            transition: opacity 0.4s ease;
        }
        .switcher-btn {
            background: transparent; border: none; 
            color: rgba(255, 255, 255, 0.6); 
            padding: 8px 24px; border-radius: 16px; font-size: 14px; font-weight: bold;
            cursor: pointer; transition: all 0.3s; -webkit-tap-highlight-color: transparent;
        }
        .switcher-btn.active {
            background: rgba(255, 255, 255, 0.85); 
            color: rgba(69, 90, 100, 0.9);
        }

        .app-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; 
            transition: opacity 0.8s ease-in-out; 
            padding: 20px; box-sizing: border-box;
        }
        .app-container.active {
            opacity: 1; pointer-events: auto; z-index: 10;
        }

        /* === SHARED UI ELEMENTS === */
        .controls { display: flex; flex-direction: column; gap: 25px; width: 100%; max-width: 350px; }
        .input-group { display: flex; flex-direction: column; gap: 10px; }
        .header-row { display: flex; justify-content: space-between; align-items: center; }
        label { font-size: 16px; font-weight: bold; opacity: 0.9; }
        
        /* 0.4s Crossfade for Inputs */
        input {
            background: rgba(255, 255, 255, 0.15); border: 1.5px solid rgba(255, 255, 255, 0.25);
            color: #FFFFFF; padding: 15px; border-radius: 14px; font-size: 22px; text-align: center;
            width: 100%; box-sizing: border-box; outline: none; -webkit-appearance: none;
            transition: color 0.4s ease; 
        }
        input::placeholder { color: rgba(255, 255, 255, 0.45); transition: color 0.4s ease; }
        
        .crossfade-out { color: transparent !important; }
        .crossfade-out::placeholder { color: transparent !important; }

        /* 0.4s Shrink & Fade for Toggle Button */
        .toggle-label {
            font-size: 13px; letter-spacing: 0.5px; background: rgba(255, 255, 255, 0.15);
            padding: 5px 12px; border-radius: 8px; cursor: pointer; 
            transition: opacity 0.4s ease, transform 0.4s ease, background 0.4s ease;
            -webkit-tap-highlight-color: transparent; display: inline-block;
        }
        .toggle-label.active { background: rgba(255, 255, 255, 0.4); }
        .toggle-label.fade-out-toggle { opacity: 0; transform: scale(0.95); }

        .question-mark {
            display: inline-block; transition: opacity 0.4s ease, max-width 0.4s ease, margin 0.4s ease;
            max-width: 10px; opacity: 1; overflow: hidden; vertical-align: bottom;
        }
        .toggle-label.active .question-mark { opacity: 0; max-width: 0; margin: 0; }

        button.main-btn {
            background-color: rgba(255, 255, 255, 0.65); color: rgba(69, 90, 100, 0.9); 
            border: none; padding: 22px; border-radius: 16px; font-size: 25px; font-weight: bold; cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.05); transition: transform 0.2s, background 0.3s;
            -webkit-tap-highlight-color: transparent; margin-top: 10px; display: flex; align-items: center; justify-content: center;
        }
        button.main-btn:active { transform: scale(0.98); background: rgba(255, 255, 255, 0.85); }

        .text-only-btn {
            background: none; border: none; color: rgba(255, 255, 255, 0.7); font-size: 18px;
            font-weight: 500; letter-spacing: 1px; cursor: pointer; margin-top: 40px; padding: 10px 20px;
            -webkit-tap-highlight-color: transparent; transition: color 0.2s;
        }
        .text-only-btn:active { color: #FFFFFF; }

        svg { transform: rotate(-90deg); width: 100%; height: 100%; }
        circle { fill: none; stroke-linecap: round; }

        /* === ZMAN AVODA SPECIFIC STYLES === */
        #avoda-timerVisual {
            display: none; position: relative; width: 300px; height: 300px;
            align-items: center; justify-content: center; transition: opacity 0.5s ease-in-out;
        }
        #avoda-timerVisual.is-paused { opacity: 0.4; }
        #ring-wrapper { position: absolute; width: 300px; height: 300px; transform-origin: center; } 
        
        .bg-ring-main { stroke: rgba(255, 255, 255, 0.2); stroke-width: 8; }
        .progress-ring-main { stroke: #FFFFFF; stroke-width: 8; stroke-dasharray: 879.64; stroke-dashoffset: 0; transition: stroke-dashoffset 0.1s linear; }
        .bg-ring-min { stroke: rgba(255, 255, 255, 0.1); stroke-width: 3; }
        .progress-ring-min { stroke: rgba(255, 255, 255, 0.4); stroke-width: 3; stroke-dasharray: 804.24; stroke-dashoffset: 0; transition: stroke-dashoffset 0.1s linear; }

        .breathe-text-wrapper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; transform-origin: center; } 

        .avoda-time-display {
            position: absolute; top: 43%; left: 50%; transform: translate(-50%, -50%);
            font-size: 58px; font-weight: 300; font-variant-numeric: tabular-nums; 
            letter-spacing: 2px; color: #FFFFFF; display: flex; align-items: center;
        }
        .avoda-time-display span { display: inline-block; transition: opacity 0.3s ease; }
        
        .avoda-breathe-hint {
            position: absolute; top: 58%; left: 0; width: 100%; text-align: center;
            font-size: 16px; font-weight: 500; letter-spacing: 1px; color: rgba(255, 255, 255, 0.45);
            line-height: 1.4; transition: opacity 0.5s ease;
            transform: translateY(-2px); 
        }
        .hint-move { animation: avoda-hint-move 10s infinite ease-in-out; }
        @keyframes avoda-hint-move { 0%, 100% { transform: translateY(-2px); } 40% { transform: translateY(2px); } }

        #colon { transform: translateY(-4px); }
        .fade-out-tick { opacity: 0; }
        .colon-pulse { animation: colon-tick 1s infinite ease-in-out; }
        @keyframes colon-tick { 0%, 100% { opacity: 1; } 50% { opacity: 0.2; } }

        #transitionScreen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            flex-direction: column; align-items: center; justify-content: center; z-index: 20; background-color: inherit;
        }
        .round-btn {
            width: 288px; height: 288px; box-sizing: border-box; border-radius: 50%; background: transparent;
            color: #FFFFFF; font-size: 48px; font-weight: 300; letter-spacing: 2px; border: 8px solid #FFFFFF;
            cursor: pointer; transition: transform 0.2s, background 0.3s; 
            display: flex; align-items: center; justify-content: center; text-align: center; 
            -webkit-tap-highlight-color: transparent; padding-left: 2px; line-height: 1;
        }
        .round-btn:active { transform: scale(0.95); background: rgba(255, 255, 255, 0.1); }

        .preset-btn-avoda {
            background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255, 255, 255, 0.3); color: #FFFFFF;
            padding: 8px 16px; border-radius: 8px; font-size: 16px; cursor: pointer; transition: all 0.2s;
            -webkit-tap-highlight-color: transparent; font-weight: normal;
        }
        .preset-btn-avoda.active { 
            background: rgba(255, 255, 255, 0.65); color: rgba(69, 90, 100, 0.9); font-weight: bold; border-color: transparent; 
        }

        /* === ZMAN NESHIMA SPECIFIC STYLES === */
        .presets { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 5px; }
        .preset-btn {
            background: rgba(255, 255, 255, 0.15); border: 1px solid rgba(255, 255, 255, 0.3); color: #FFFFFF;
            padding: 10px 14px; border-radius: 8px; font-size: 16px; cursor: pointer; transition: background 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        .preset-btn:active { background: rgba(255, 255, 255, 0.4); }

        .ring-container { position: relative; width: 250px; height: 250px; }
        .ring-container svg { transform: rotate(-90deg); transform-origin: center; } 
        .bg-ring { stroke: rgba(255, 255, 255, 0.2); stroke-width: 8; }
        #neshima-ring { stroke: #FFFFFF; stroke-width: 8; stroke-dasharray: 32 750; stroke-dashoffset: 16; transform-origin: center; } 

        .neshima-time-display {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center; text-align: center;
            font-size: 84px; font-weight: bold; color: #FFFFFF; 
            transition: opacity 0.2s ease; margin: 0; padding: 0; line-height: 1;
        }
        
        .neshima-time-display.text-cinematic { font-size: 36px !important; line-height: 1.15; }
        .neshima-time-display.text-done { font-size: 64px !important; line-height: 1; }
        .fade-out { opacity: 0; }

        #neshima-post-btn {
            position: absolute; top: 280px; left: 50%; transform: translateX(-50%);
            white-space: nowrap; padding: 8px 16px; font-size: 14px; box-shadow: 0 4px 15px rgba(0,0,0,0.05); border-radius: 10px;
        }
        #neshima-stats {
            position: absolute; top: 280px; left: 50%; transform: translateX(-50%); width: 250px; 
            justify-content: space-between; font-size: 14px; color: rgba(255,255,255,0.6); letter-spacing: 1px;
        }
        #neshima-stopBtn {
            position: absolute; top: 330px; left: 50%; transform: translateX(-50%); margin: 0; white-space: nowrap;
        }
    </style>
</head>
<body>

    <div id="app-switcher">
        <button class="switcher-btn active" id="btn-switch-avoda">Avoda</button>
        <button class="switcher-btn" id="btn-switch-neshima">Neshima</button>
    </div>

    <div id="app-avoda" class="app-container active">
        <div class="controls" id="avoda-controls">
            <div class="input-group">
                <div class="header-row">
                    <label>Focus Time (minutes):</label>
                    <div id="avodaSoftnoiseToggle" class="toggle-label">softnoise</div>
                </div>
                <input type="number" id="focusInput" value="25" inputmode="decimal" step="0.1">
            </div>
            <div class="input-group">
                <div class="header-row">
                    <label>Break Time (minutes):</label>
                </div>
                <input type="number" id="breakInput" value="5" inputmode="decimal" step="0.1">
            </div>

            <div class="input-group" style="align-items: center; margin-top: 5px;">
                <div style="color: rgba(255,255,255,0.7); font-size: 20px; font-weight: 300; letter-spacing: 1px; margin-bottom: 8px; text-align: center;">How do you want to breathe?</div>
                <div class="presets" style="gap: 12px;">
                    <button class="preset-btn-avoda" data-inhale="4" data-exhale="4">4 - 4</button>
                    <button class="preset-btn-avoda active" data-inhale="5.5" data-exhale="5.5">5<span style="font-size: 0.75em;">.5</span> - 5<span style="font-size: 0.75em;">.5</span></button>
                    <button class="preset-btn-avoda" data-inhale="6" data-exhale="8">6 - 8</button>
                    <button class="preset-btn-avoda" data-inhale="6" data-exhale="10">6 - 10</button>
                </div>
            </div>

            <button id="avoda-startBtn" class="main-btn">Work</button>
        </div>

        <div id="avoda-timerVisual">
            <div id="ring-wrapper">
                <svg viewBox="0 0 300 300">
                    <circle class="bg-ring-min" cx="150" cy="150" r="128"></circle>
                    <circle class="progress-ring-min" id="min-ring" cx="150" cy="150" r="128"></circle>
                    <circle class="bg-ring-main" cx="150" cy="150" r="140"></circle>
                    <circle class="progress-ring-main" id="main-ring" cx="150" cy="150" r="140"></circle>
                </svg>
            </div>
            <div id="text-wrapper" class="breathe-text-wrapper">
                <div class="avoda-time-display" id="avoda-display">
                    <span id="digit-m1">2</span><span id="digit-m2">5</span><span id="colon">:</span><span id="digit-s1">0</span><span id="digit-s2">0</span>
                </div>
                <div class="avoda-breathe-hint" id="avoda-hint-text">inhale and exhale<br>with the circle</div>
            </div>
        </div>

        <div id="transitionScreen">
            <button id="nextPhaseBtn" class="round-btn">Start<br>Break</button>
            <button id="endSessionBtn" class="text-only-btn" style="margin-top: 30px;">End Session</button>
        </div>
        
        <button id="avoda-resetBtn" class="text-only-btn" style="display: none; position: relative; z-index: 10;">Reset</button>
    </div>

    <div id="app-neshima" class="app-container">
        <div class="controls" id="neshima-controls">
            <div class="presets">
                <button class="preset-btn" data-seq="4-6" data-limit="5" data-limittype="cycles">Cool Down</button>
                <button class="preset-btn" data-seq="6-6">King</button>
                <button class="preset-btn" data-seq="4-4-4-4">Box</button>
                <button class="preset-btn" data-seq="4-4-8-4">Soothe</button>
                <button class="preset-btn" data-seq="2-2" data-limit="30" data-limittype="cycles">New Universe</button>
                <button class="preset-btn" data-seq="1-1" data-limit="45" data-limittype="cycles">Acid</button>
            </div>
            <div class="input-group">
                <div class="header-row">
                    <label>Sequence (sec):</label>
                    <div style="display: flex; gap: 6px;">
                        <div id="headstartToggle" class="toggle-label active">3s headstart</div>
                        <div id="neshimaSoftnoiseToggle" class="toggle-label">softnoise<span class="question-mark">?</span></div>
                    </div>
                </div>
                <input type="text" id="sequence" value="6-6" inputmode="text">
            </div>
            <div class="input-group">
                <div class="header-row">
                    <label>Finish After (optional):</label>
                    <div id="limitToggle" class="toggle-label active">minutes</div>
                </div>
                <input type="number" id="limitInput" placeholder="Endless" inputmode="numeric">
            </div>
            <button id="neshima-startBtn" class="main-btn">Breathe</button>
        </div>

        <div class="ring-container" id="neshima-timerVisual" style="display: none;">
            <svg width="250" height="250" id="neshima-svg">
                <circle class="bg-ring" cx="125" cy="125" r="115"></circle>
                <circle id="neshima-ring" cx="125" cy="125" r="115"></circle>
            </svg>
            <div class="neshima-time-display" id="neshima-display">3</div>
            
            <div id="neshima-post-btn" class="toggle-label" style="display: none;">15-30 hold and release?</div>
            
            <div id="neshima-stats" style="display: none;">
                <div id="stat-cycles">Cycles: 0</div>
                <div id="stat-remaining"></div>
            </div>

            <button id="neshima-stopBtn" class="text-only-btn" style="display: none;">Stop</button>
        </div>

    </div>

    <script>
        /* === GLOBAL / SHARED UTILS === */
        let wakeLock = null; let isAudioSessionUnlocked = false;
        const appSwitcher = document.getElementById('app-switcher'); const btnAvoda = document.getElementById('btn-switch-avoda'); const btnNeshima = document.getElementById('btn-switch-neshima');
        const appAvoda = document.getElementById('app-avoda'); const appNeshima = document.getElementById('app-neshima');
        
        const silentAudioWav = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
        const iosUnlocker = new Audio(silentAudioWav); iosUnlocker.loop = false;

        const delay = ms => new Promise(res => setTimeout(res, ms));

        async function requestWakeLock() { try { if ('wakeLock' in navigator) wakeLock = await navigator.wakeLock.request('screen'); } catch (err) {} }
        function releaseWakeLock() { if (wakeLock !== null) { wakeLock.release(); wakeLock = null; } }
        function toggleSwitcherVisibility(hide) { appSwitcher.style.opacity = hide ? '0' : '1'; appSwitcher.style.pointerEvents = hide ? 'none' : 'auto'; }

        btnAvoda.addEventListener('click', () => {
            if (btnAvoda.classList.contains('active')) return;
            if (isNeshimaRunning || isPostSessionRunning) neshimaStopTimer();
            btnAvoda.classList.add('active'); btnNeshima.classList.remove('active');
            appNeshima.classList.remove('active'); appAvoda.classList.add('active'); document.body.style.backgroundColor = FOCUS_COLOR_1;
        });

        btnNeshima.addEventListener('click', () => {
            if (btnNeshima.classList.contains('active')) return;
            if (isAvodaRunning) avodaResetTimer();
            btnNeshima.classList.add('active'); btnAvoda.classList.remove('active');
            appAvoda.classList.remove('active'); appNeshima.classList.add('active'); document.body.style.backgroundColor = COLOR_BLUE;
        });

        /* =========================================
           AUDIO COMPRESSION ENGINE
           ========================================= */
        let audioCtx; let masterCompressor;
        function unlockAudioCtx() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterCompressor = audioCtx.createDynamicsCompressor();
                masterCompressor.threshold.value = -15; masterCompressor.knee.value = 30; masterCompressor.ratio.value = 12;
                masterCompressor.attack.value = 0.003; masterCompressor.release.value = 0.25;
                masterCompressor.connect(audioCtx.destination);
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
            if (!isAudioSessionUnlocked) { iosUnlocker.play().then(() => isAudioSessionUnlocked = true).catch(e=>{}); const buffer = audioCtx.createBuffer(1, 1, 22050); const source = audioCtx.createBufferSource(); source.buffer = buffer; source.connect(audioCtx.destination); source.start(0); isAudioSessionUnlocked = true; }
        }

        function createPinkNoiseBuffer(context) {
            const bufferSize = context.sampleRate * 5; const buffer = context.createBuffer(1, bufferSize, context.sampleRate);
            const output = buffer.getChannelData(0); let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1; b0 = 0.99886 * b0 + white * 0.0555179; b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520; b3 = 0.86650 * b3 + white * 0.3104856; b4 = 0.55000 * b4 + white * 0.5329522;
                b5 = -0.7616 * b5 - white * 0.0168980; output[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362; output[i] *= 0.11; b6 = white * 0.115926;
            } return buffer;
        }

        /* =========================================
           ZMAN AVODA LOGIC 
           ========================================= */
        let avodaNoiseSource = null; let avodaNoiseFilter = null; let avodaNoiseGain = null;
        let isAvodaSoftnoiseOn = false; let isAvodaRunning = false; let isAvodaPaused = false;
        let avodaCurrentMsLeft = 0; let avodaEngineInterval; 
        let avodaPhaseEndTime = 0; let avodaPhaseDurationMs = 0; let avodaPhaseRealStartTime = 0; 
        let isFocusMode = true; let avodaLastDisplayVal = "";
        let currentAvodaPhaseStr = ""; 
        let c1, c2, isC1;
        
        let avodaInhale = 5.5; let avodaExhale = 5.5;

        const FOCUS_COLOR_1 = '#FFCDD2'; const FOCUS_COLOR_2 = '#81D4FA'; const BREAK_COLOR_1 = '#A8E6CF'; const BREAK_COLOR_2 = '#E4C95A'; 
        const circMain = 879.64; const circMin = 804.24;

        const mainRing = document.getElementById('main-ring'); const minRing = document.getElementById('min-ring');
        const ringWrapper = document.getElementById('ring-wrapper'); const textWrapper = document.getElementById('text-wrapper');
        const colonEl = document.getElementById('colon'); const avodaStartBtn = document.getElementById('avoda-startBtn'); const avodaResetBtn = document.getElementById('avoda-resetBtn');
        const avodaControls = document.getElementById('avoda-controls'); const avodaTimerVisual = document.getElementById('avoda-timerVisual');
        const focusInput = document.getElementById('focusInput'); const breakInput = document.getElementById('breakInput');
        const transitionScreen = document.getElementById('transitionScreen'); const nextPhaseBtn = document.getElementById('nextPhaseBtn'); const endSessionBtn = document.getElementById('endSessionBtn');

        document.querySelectorAll('.preset-btn-avoda').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.preset-btn-avoda').forEach(b => b.classList.remove('active'));
                e.currentTarget.classList.add('active'); 
                avodaInhale = parseFloat(e.currentTarget.dataset.inhale);
                avodaExhale = parseFloat(e.currentTarget.dataset.exhale);
            });
        });

        let avodaHintInterval; let currentHintIndex = 0;
        const avodaHints = ["inhale and exhale<br>with the circle", "it will help<br>you focus", "keep<br>it up"];

        function startAvodaHintLoop() {
            clearInterval(avodaHintInterval); currentHintIndex = 0;
            const hintEl = document.getElementById('avoda-hint-text');
            hintEl.innerHTML = avodaHints[0]; hintEl.style.opacity = 1;
            avodaHintInterval = setInterval(() => {
                hintEl.style.opacity = 0;
                setTimeout(() => {
                    if (!isAvodaRunning) return;
                    currentHintIndex = (currentHintIndex + 1) % avodaHints.length;
                    hintEl.innerHTML = avodaHints[currentHintIndex];
                    hintEl.style.opacity = 1;
                }, 500);
            }, (avodaInhale + avodaExhale) * 1000); 
        }

        function playStartBeep() {
            unlockAudioCtx();
            for (let i = 0; i < 3; i++) {
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'sine'; osc.frequency.value = 261; const startTime = audioCtx.currentTime + (i * 0.08);
                gain.gain.setValueAtTime(0, startTime); gain.gain.linearRampToValueAtTime(1, startTime + 0.01); gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.07);
                osc.connect(gain); gain.connect(masterCompressor); osc.start(startTime); osc.stop(startTime + 0.08);
            }
        }

        function playEndChime() {
            unlockAudioCtx(); const interval = 1 / 10; 
            for (let i = 0; i < 5; i++) {
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.type = 'sine'; osc.frequency.value = 329; const startTime = audioCtx.currentTime + (i * interval); 
                gain.gain.setValueAtTime(0, startTime); gain.gain.linearRampToValueAtTime(1, startTime + 0.01); gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.09); 
                osc.connect(gain); gain.connect(masterCompressor); osc.start(startTime); osc.stop(startTime + 0.1);
            }
        }

        function startAvodaSoftnoise() {
            unlockAudioCtx(); stopAvodaSoftnoise(); 
            avodaNoiseSource = audioCtx.createBufferSource(); avodaNoiseSource.buffer = createPinkNoiseBuffer(audioCtx); avodaNoiseSource.loop = true;
            avodaNoiseFilter = audioCtx.createBiquadFilter(); avodaNoiseFilter.type = 'bandpass'; avodaNoiseFilter.frequency.value = 350; avodaNoiseFilter.Q.value = 0.6; 
            avodaNoiseGain = audioCtx.createGain(); avodaNoiseGain.gain.value = 0.08; 
            avodaNoiseSource.connect(avodaNoiseFilter); avodaNoiseFilter.connect(avodaNoiseGain); avodaNoiseGain.connect(masterCompressor); avodaNoiseSource.start();
        }

        function stopAvodaSoftnoise() { if (avodaNoiseSource) { try { avodaNoiseSource.stop(); } catch(e){} avodaNoiseSource.disconnect(); avodaNoiseSource = null; } }

        document.getElementById('avodaSoftnoiseToggle').addEventListener('click', (e) => {
            unlockAudioCtx(); isAvodaSoftnoiseOn = !isAvodaSoftnoiseOn; e.target.classList.toggle('active', isAvodaSoftnoiseOn);
            if (isAvodaRunning && !isAvodaPaused) { if (isAvodaSoftnoiseOn) startAvodaSoftnoise(); else stopAvodaSoftnoise(); }
        });

        function avodaUpdateDisplayTick(strVal) {
            if (strVal === avodaLastDisplayVal) return;
            const oldChars = avodaLastDisplayVal.split(''); const newChars = strVal.split('');
            const digitIds = ['digit-m1', 'digit-m2', 'colon', 'digit-s1', 'digit-s2'];
            for (let i = 0; i < 5; i++) {
                if (i === 2) continue; 
                if (oldChars[i] !== newChars[i] || avodaLastDisplayVal === "") {
                    const el = document.getElementById(digitIds[i]); el.classList.add('fade-out-tick');
                    setTimeout(() => { el.innerText = newChars[i]; el.classList.remove('fade-out-tick'); }, 300); 
                }
            } avodaLastDisplayVal = strVal;
        }

        function avodaSetPhase(isFocus) {
            isFocusMode = isFocus; avodaPhaseRealStartTime = Date.now();
            const rawVal = parseFloat(isFocus ? focusInput.value : breakInput.value); const minutes = (isNaN(rawVal) || rawVal <= 0) ? 1 : rawVal;
            avodaPhaseDurationMs = Math.floor(minutes * 60000); avodaPhaseEndTime = Date.now() + avodaPhaseDurationMs;
            
            colonEl.classList.remove('colon-pulse'); void colonEl.offsetWidth; colonEl.classList.add('colon-pulse'); 

            c1 = isFocusMode ? FOCUS_COLOR_1 : BREAK_COLOR_1; c2 = isFocusMode ? FOCUS_COLOR_2 : BREAK_COLOR_2;
            isC1 = true; currentAvodaPhaseStr = "inhale"; document.body.style.backgroundColor = c1; 
            
            if (isAvodaSoftnoiseOn) startAvodaSoftnoise(); playStartBeep(); startAvodaHintLoop();
        }

        function avodaRunEngine() {
            if (!isAvodaRunning) return;
            const now = Date.now(); let msLeft = avodaPhaseEndTime - now;
            if (msLeft <= 0) {
                clearInterval(avodaEngineInterval); clearInterval(avodaHintInterval);
                isAvodaRunning = false; stopAvodaSoftnoise(); playEndChime(); releaseWakeLock();
                avodaTimerVisual.style.display = 'none'; avodaResetBtn.style.display = 'none'; transitionScreen.style.display = 'flex';
                nextPhaseBtn.innerHTML = isFocusMode ? "Start<br>Break" : "Work"; toggleSwitcherVisibility(false); return;
            }
            const mins = Math.floor(Math.ceil(msLeft / 1000) / 60); const secs = Math.ceil(msLeft / 1000) % 60;
            avodaUpdateDisplayTick(`${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`);
            mainRing.style.strokeDashoffset = circMain - ((msLeft / avodaPhaseDurationMs) * circMain);
            minRing.style.strokeDashoffset = circMin - (((msLeft % 60000) / 60000) * circMin);

            const cycleDuration = (avodaInhale + avodaExhale) * 1000;
            const cycleTime = (now - avodaPhaseRealStartTime) % cycleDuration;
            const isAvodaInhalePhase = cycleTime < (avodaInhale * 1000);
            
            const newPhaseStr = isAvodaInhalePhase ? "inhale" : "exhale";
            if (currentAvodaPhaseStr !== newPhaseStr) {
                currentAvodaPhaseStr = newPhaseStr;
                isC1 = !isC1; document.body.style.backgroundColor = isC1 ? c1 : c2;
            }

            let progress = isAvodaInhalePhase ? cycleTime / (avodaInhale * 1000) : (cycleTime - avodaInhale * 1000) / (avodaExhale * 1000);
            const ease = (t) => 0.5 - Math.cos(t * Math.PI) / 2;
            const e = ease(progress);

            const ringScale = isAvodaInhalePhase ? 0.9 + (e * 0.2) : 1.1 - (e * 0.2);
            const textOp = isAvodaInhalePhase ? 0.15 + (e * 0.85) : 1.0 - (e * 0.85);
            const textSc = isAvodaInhalePhase ? 0.95 + (e * 0.1) : 1.05 - (e * 0.1);
            
            const hintY = isAvodaInhalePhase ? -2 + (e * 4) : 2 - (e * 4); 

            ringWrapper.style.transform = `scale(${ringScale})`;
            textWrapper.style.opacity = textOp;
            textWrapper.style.transform = `scale(${textSc})`;
            document.getElementById('avoda-hint-text').style.transform = `translateY(${hintY}px)`;

            if (isAvodaSoftnoiseOn && avodaNoiseFilter && avodaNoiseGain) {
                const currentFreq = isAvodaInhalePhase ? 350 + (e * 250) : 600 - (e * 250);
                const currentVol = isAvodaInhalePhase ? 0.06 + (e * 0.04) : 0.10 - (e * 0.04);
                avodaNoiseFilter.frequency.setTargetAtTime(currentFreq, audioCtx.currentTime, 0.05); 
                avodaNoiseGain.gain.setTargetAtTime(currentVol, audioCtx.currentTime, 0.05);
            }
        }

        avodaTimerVisual.addEventListener('click', () => {
            if (!isAvodaRunning) return; unlockAudioCtx();
            if (isAvodaPaused) {
                isAvodaPaused = false; avodaPhaseEndTime = Date.now() + avodaCurrentMsLeft; avodaEngineInterval = setInterval(avodaRunEngine, 16);
                avodaTimerVisual.classList.remove('is-paused'); colonEl.style.animationPlayState = 'running'; 
                if (isAvodaSoftnoiseOn) startAvodaSoftnoise(); requestWakeLock(); startAvodaHintLoop();
            } else {
                isAvodaPaused = true; clearInterval(avodaEngineInterval); clearInterval(avodaHintInterval); avodaCurrentMsLeft = avodaPhaseEndTime - Date.now();
                avodaTimerVisual.classList.add('is-paused'); colonEl.style.animationPlayState = 'paused'; 
                stopAvodaSoftnoise(); releaseWakeLock();
            }
        });

        function avodaResetTimer() {
            isAvodaRunning = false; isAvodaPaused = false; clearInterval(avodaEngineInterval); clearInterval(avodaHintInterval);
            stopAvodaSoftnoise(); releaseWakeLock();
            avodaTimerVisual.classList.remove('is-paused'); colonEl.style.animationPlayState = 'running'; 
            
            ringWrapper.style.transform = `scale(1)`; textWrapper.style.opacity = 1; textWrapper.style.transform = `scale(1)`; document.getElementById('avoda-hint-text').style.transform = `translateY(-2px)`;
            
            avodaTimerVisual.style.display = 'none'; avodaResetBtn.style.display = 'none'; transitionScreen.style.display = 'none'; 
            avodaControls.style.display = 'flex'; document.body.style.backgroundColor = FOCUS_COLOR_1; toggleSwitcherVisibility(false);
        }

        function startAvodaFlow(isFocus) {
            unlockAudioCtx(); requestWakeLock(); toggleSwitcherVisibility(true);
            avodaControls.style.display = 'none'; transitionScreen.style.display = 'none'; avodaTimerVisual.style.display = 'flex'; avodaResetBtn.style.display = 'block'; 
            isAvodaRunning = true; isAvodaPaused = false; avodaLastDisplayVal = ""; avodaSetPhase(isFocus); avodaEngineInterval = setInterval(avodaRunEngine, 16);
        }

        avodaStartBtn.addEventListener('click', () => startAvodaFlow(true)); nextPhaseBtn.addEventListener('click', () => startAvodaFlow(!isFocusMode));
        avodaResetBtn.addEventListener('click', avodaResetTimer); endSessionBtn.addEventListener('click', avodaResetTimer);


        /* =========================================
           ZMAN NESHIMA LOGIC & CINEMATIC SEQUENCE
           ========================================= */
        function buildWavDataURI(freq, duration = 0.085, vol = 0.87, decay = 92.1, attack = 0.01) {
            const sampleRate = 44100; const samples = Math.floor(sampleRate * duration); const buffer = new ArrayBuffer(44 + samples * 2);
            const view = new DataView(buffer); const writeString = (offset, string) => { for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i)); };
            writeString(0, 'RIFF'); view.setUint32(4, 36 + samples * 2, true); writeString(8, 'WAVE'); writeString(12, 'fmt ');
            view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true); view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true); view.setUint16(32, 2, true); view.setUint16(34, 16, true); writeString(36, 'data'); view.setUint32(40, samples * 2, true);
            let offset = 44;
            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate; let env = 0, timeInWave = 0;
                if (t >= 0.015 && t <= 0.015 + attack) { env = (t - 0.015) / attack; timeInWave = t - 0.015; } else if (t > 0.015 + attack && t <= duration - 0.015) { env = Math.exp(-decay * (t - (0.015 + attack))); timeInWave = t - 0.015; }
                const sine = freq === 0 ? 0 : Math.sin(2 * Math.PI * freq * timeInWave); const sample = Math.max(-1, Math.min(1, sine)) * 32767 * env * vol; view.setInt16(offset, sample, true); offset += 2;
            } let binary = ''; const bytes = new Uint8Array(buffer); const chunkSize = 8192; for (let i = 0; i < bytes.length; i += chunkSize) binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize)); return 'data:audio/wav;base64,' + btoa(binary);
        }

        const audioStep = new Audio(buildWavDataURI(396, 0.085, 0.87, 92.1, 0.01)); const audioRestart = new Audio(buildWavDataURI(432, 0.085, 0.87, 92.1, 0.01)); const audioDone = new Audio(buildWavDataURI(285, 0.085, 0.87, 92.1, 0.01));    
        function playNeshimaBeep(type) { let snd = audioStep; if (type === 'restart') snd = audioRestart; if (type === 'done') snd = audioDone; snd.currentTime = 0; snd.play().catch(() => {}); }

        const COLOR_BLUE = '#81D4FA'; const COLOR_GREEN = '#A8E6CF'; const circumference = 2 * Math.PI * 115;
        let isNeshimaRunning = false; let isPostSessionRunning = false; let neshimaEngineInterval; let sequence = []; let currentIndex = 0; let stepEndTime = 0;
        let sessionEndTime = 0; let useSessionEnd = false; let targetCycles = 0; let cyclesCompleted = 0; let useCycleLimit = false; let limitReachedWaitingForCycleEnd = false; 
        let isBlueBackground = true; let neshimaLastDisplayVal = ""; let neshimaAudioUnlocked = false; let isHeadstartOn = true; let isMinutesLimit = true;
        let isNeshimaSoftnoiseOn = false; let neshimaNoiseSource = null; let neshimaNoiseFilter = null; let neshimaNoiseGain = null;

        const neshimaRing = document.getElementById('neshima-ring'); const neshimaDisplay = document.getElementById('neshima-display'); const neshimaSvg = document.getElementById('neshima-svg'); 
        const neshimaStartBtn = document.getElementById('neshima-startBtn'); const neshimaStopBtn = document.getElementById('neshima-stopBtn');
        const neshimaControls = document.getElementById('neshima-controls'); const neshimaTimerVisual = document.getElementById('neshima-timerVisual');
        const sequenceInput = document.getElementById('sequence'); const limitInput = document.getElementById('limitInput');
        const headToggle = document.getElementById('headstartToggle'); const limitToggle = document.getElementById('limitToggle'); const neshimaSoftnoiseToggle = document.getElementById('neshimaSoftnoiseToggle');
        const statsContainer = document.getElementById('neshima-stats'); const statCycles = document.getElementById('stat-cycles'); const statRemaining = document.getElementById('stat-remaining');
        const neshimaPostBtn = document.getElementById('neshima-post-btn');

        headToggle.addEventListener('click', () => { isHeadstartOn = !isHeadstartOn; headToggle.classList.toggle('active', isHeadstartOn); });
        
        const triggerSmoothToggle = (toMinutes) => {
            if (toMinutes && !isMinutesLimit) {
                limitToggle.classList.add('fade-out-toggle');
                setTimeout(() => { isMinutesLimit = true; limitToggle.innerText = 'minutes'; limitToggle.classList.remove('fade-out-toggle'); }, 400);
            } else if (!toMinutes && isMinutesLimit) {
                limitToggle.classList.add('fade-out-toggle');
                setTimeout(() => { isMinutesLimit = false; limitToggle.innerText = 'cycles'; limitToggle.classList.remove('fade-out-toggle'); }, 400);
            }
        };

        limitToggle.addEventListener('click', () => triggerSmoothToggle(!isMinutesLimit));
        
        neshimaSoftnoiseToggle.addEventListener('click', () => { unlockAudioCtx(); isNeshimaSoftnoiseOn = !isNeshimaSoftnoiseOn; neshimaSoftnoiseToggle.classList.toggle('active', isNeshimaSoftnoiseOn); if (isNeshimaRunning) { if (isNeshimaSoftnoiseOn) startNeshimaSoftnoise(); else stopNeshimaSoftnoise(); } });
        
        document.querySelectorAll('#neshima-controls .preset-btn').forEach(btn => { 
            btn.addEventListener('click', () => { 
                
                sequenceInput.classList.add('crossfade-out');
                limitInput.classList.add('crossfade-out');

                setTimeout(() => {
                    // Swap the values while invisible
                    sequenceInput.value = btn.dataset.seq; 
                    if(btn.dataset.limit) {
                        limitInput.value = btn.dataset.limit;
                        triggerSmoothToggle(btn.dataset.limittype === 'minutes');
                    } else {
                        limitInput.value = ""; 
                        triggerSmoothToggle(true); 
                    }
                    
                    // THE FIX: Wait 20ms for the browser to render the invisible placeholder 
                    // before we tell it to fade back in.
                    setTimeout(() => {
                        sequenceInput.classList.remove('crossfade-out');
                        limitInput.classList.remove('crossfade-out');
                    }, 20);
                    
                }, 400);
            }); 
        });

        function startNeshimaSoftnoise() {
            if (!audioCtx) unlockAudioCtx(); stopNeshimaSoftnoise(); 
            neshimaNoiseSource = audioCtx.createBufferSource(); neshimaNoiseSource.buffer = createPinkNoiseBuffer(audioCtx); neshimaNoiseSource.loop = true;
            neshimaNoiseFilter = audioCtx.createBiquadFilter(); neshimaNoiseFilter.type = 'bandpass'; neshimaNoiseFilter.frequency.value = 250; neshimaNoiseFilter.Q.value = 0.8; 
            neshimaNoiseGain = audioCtx.createGain(); neshimaNoiseGain.gain.value = 0.02; 
            neshimaNoiseSource.connect(neshimaNoiseFilter); neshimaNoiseFilter.connect(neshimaNoiseGain); neshimaNoiseGain.connect(masterCompressor); neshimaNoiseSource.start();
        }

        function stopNeshimaSoftnoise() { if (neshimaNoiseSource) { try { neshimaNoiseSource.stop(); } catch(e){} neshimaNoiseSource.disconnect(); neshimaNoiseSource = null; } }

        let pendingDisplayVal = ""; let neshimaUpdateId = 0;

        function neshimaUpdateDisplay(val, forceUpdate = false) {
            const strVal = String(val); 
            if (strVal === pendingDisplayVal) return; 
            pendingDisplayVal = strVal;

            const currentId = ++neshimaUpdateId;
            neshimaDisplay.classList.add('fade-out');
            
            setTimeout(() => { 
                if (neshimaUpdateId !== currentId) return;
                if (!forceUpdate && !isNeshimaRunning && !isPostSessionRunning) return;
                
                neshimaDisplay.innerHTML = strVal; 
                
                const lowerVal = strVal.toLowerCase();
                if (lowerVal === "finish" || lowerVal === "done") {
                    neshimaDisplay.classList.add('text-done');
                    neshimaDisplay.classList.remove('text-cinematic');
                } else if (strVal.includes("<br>") || strVal.includes("take")) {
                    neshimaDisplay.classList.add('text-cinematic');
                    neshimaDisplay.classList.remove('text-done');
                } else {
                    neshimaDisplay.classList.remove('text-done');
                    neshimaDisplay.classList.remove('text-cinematic');
                }
                
                neshimaDisplay.style.transform = `scale(${window.lastNeshimaTextScale || 1})`;
                neshimaDisplay.classList.remove('fade-out'); 
                neshimaLastDisplayVal = strVal; 
            }, 150);
        }

        function updateNeshimaHUD() {
            statCycles.innerText = `Cycles: ${cyclesCompleted}`;
            if (useCycleLimit) { statRemaining.innerText = `${Math.max(0, targetCycles - cyclesCompleted)} left`; } 
            else if (useSessionEnd) { statRemaining.innerText = `${Math.ceil(Math.max(0, sessionEndTime - Date.now()) / 60000)} min left`; }
        }

        function playCompletionChime() { playNeshimaBeep('done'); setTimeout(() => playNeshimaBeep('done'), 333); setTimeout(() => playNeshimaBeep('done'), 666); }

        function neshimaRunEngine() {
            if (!isNeshimaRunning) return; const now = Date.now();
            if (useSessionEnd && now >= sessionEndTime) { limitReachedWaitingForCycleEnd = true; }
            let timeLeft = stepEndTime - now; 
            
            if (timeLeft <= 0) {
                currentIndex = (currentIndex + 1) % sequence.length; const isCycleRestart = (currentIndex === 0);
                if (isCycleRestart) { cyclesCompleted++; updateNeshimaHUD(); if ((useCycleLimit && cyclesCompleted >= targetCycles) || limitReachedWaitingForCycleEnd) { neshimaEndSession(); return; } }
                playNeshimaBeep(isCycleRestart ? 'restart' : 'step'); isBlueBackground = !isBlueBackground; document.body.style.backgroundColor = isBlueBackground ? COLOR_BLUE : COLOR_GREEN;
                stepEndTime += (sequence[currentIndex] * 1000); timeLeft = stepEndTime - now;
            }

            const currentStepDuration = sequence[currentIndex] * 1000;
            let currentBeat = Math.max(1, Math.ceil(timeLeft / 1000)); neshimaUpdateDisplay(currentBeat);
            const percentage = Math.max(0, timeLeft) / currentStepDuration; neshimaRing.style.transform = `rotate(${-(percentage * 360)}deg)`;

            let phaseType = 'hold';
            if (sequence.length === 2) { phaseType = currentIndex === 0 ? 'inhale' : 'exhale'; } else if (sequence.length === 3) { phaseType = currentIndex === 0 ? 'inhale' : (currentIndex === 1 ? 'hold-high' : 'exhale'); } else if (sequence.length >= 4) { phaseType = currentIndex === 0 ? 'inhale' : (currentIndex === 1 ? 'hold-high' : (currentIndex === 2 ? 'exhale' : 'hold-low')); }

            const progress = 1 - percentage; const maxRingScale = 1.15; const minRingScale = 0.88; const maxTextScale = 1.08; const minTextScale = 0.92; let ringScale = 1, textScale = 1;
            
            if (phaseType === 'inhale') { ringScale = minRingScale + (progress * (maxRingScale - minRingScale)); textScale = minTextScale + (progress * (maxTextScale - minTextScale)); } 
            else if (phaseType === 'exhale') { ringScale = maxRingScale - (progress * (maxRingScale - minRingScale)); textScale = maxTextScale - (progress * (maxTextScale - minTextScale)); } 
            else if (phaseType === 'hold-high') { ringScale = maxRingScale; textScale = maxTextScale; } 
            else if (phaseType === 'hold-low') { ringScale = minRingScale; textScale = minTextScale; }

            window.lastNeshimaTextScale = textScale;
            neshimaSvg.style.transform = `rotate(-90deg) scale(${ringScale})`; neshimaDisplay.style.transform = `scale(${textScale})`;

            if (isNeshimaSoftnoiseOn && neshimaNoiseFilter && neshimaNoiseGain) {
                const minFreq = 250; const maxFreq = 800; const minVol = 0.02; const maxVol = 0.1; let currentFreq = minFreq; let currentVol = minVol;
                if (phaseType === 'inhale') { currentFreq = minFreq + (progress * (maxFreq - minFreq)); currentVol = minVol + (progress * (maxVol - minVol)); } else if (phaseType === 'exhale') { currentFreq = maxFreq - (progress * (maxFreq - minFreq)); currentVol = maxVol - (progress * (maxVol - minVol)); } else if (phaseType === 'hold-high') { currentFreq = maxFreq; currentVol = maxVol; } else if (phaseType === 'hold-low') { currentFreq = minFreq; currentVol = minVol; }
                neshimaNoiseFilter.frequency.setTargetAtTime(currentFreq, audioCtx.currentTime, 0.03); neshimaNoiseGain.gain.setTargetAtTime(currentVol, audioCtx.currentTime, 0.03);
            }
        }

        function neshimaEndSession() {
            playCompletionChime(); isNeshimaRunning = false; clearInterval(neshimaEngineInterval); releaseWakeLock(); stopNeshimaSoftnoise();
            neshimaRing.style.transform = `rotate(0deg)`; 
            
            neshimaStopBtn.style.display = 'block'; 
            neshimaStopBtn.innerText = "Finish"; 
            neshimaPostBtn.style.display = 'block'; 
            
            document.getElementById('neshima-stats').style.display = 'none';
            toggleSwitcherVisibility(false);
            
            neshimaSvg.style.transform = `rotate(-90deg) scale(1)`; 
            window.lastNeshimaTextScale = 1; neshimaDisplay.style.transform = `scale(1)`; 
            
            neshimaUpdateDisplay("Done", true);
        }

        function neshimaStopTimer() {
            isNeshimaRunning = false; isPostSessionRunning = false; clearInterval(neshimaEngineInterval); clearInterval(cinematicInterval);
            releaseWakeLock(); stopNeshimaSoftnoise(); if(globalResetListener) { document.removeEventListener('click', globalResetListener); globalResetListener = null; }
            neshimaTimerVisual.style.display = 'none'; neshimaStopBtn.style.display = 'none'; neshimaPostBtn.style.display = 'none';
            neshimaControls.style.display = 'flex'; document.body.style.backgroundColor = COLOR_BLUE; 
            
            pendingDisplayVal = ""; neshimaLastDisplayVal = ""; toggleSwitcherVisibility(false);
            neshimaRing.style.transform = `rotate(0deg)`; neshimaRing.style.strokeDasharray = "32 750"; neshimaRing.style.strokeDashoffset = 16;
            
            neshimaSvg.style.transition = "none"; neshimaDisplay.style.transition = "opacity 0.2s ease";
            neshimaSvg.style.transform = `rotate(-90deg) scale(1)`; 
            window.lastNeshimaTextScale = 1; neshimaDisplay.style.transform = `scale(1)`; 
            
            document.getElementById('neshima-stats').style.display = 'none';
        }

        neshimaStartBtn.addEventListener('click', () => {
            if (!neshimaAudioUnlocked) { if (!isAudioSessionUnlocked) { iosUnlocker.play().catch(e=>{}); isAudioSessionUnlocked = true; } [audioStep, audioRestart, audioDone].forEach(a => { a.muted = true; a.play().then(() => { a.pause(); a.currentTime = 0; a.muted = false; }).catch(()=>{}); }); neshimaAudioUnlocked = true; }
            sequence = sequenceInput.value.split('-').map(num => parseFloat(num.trim())).filter(num => !isNaN(num) && num > 0); if (sequence.length === 0) return;
            const limitVal = parseFloat(limitInput.value); useSessionEnd = false; useCycleLimit = false; cyclesCompleted = 0; limitReachedWaitingForCycleEnd = false;
            if (!isNaN(limitVal) && limitVal > 0) { if (isMinutesLimit) { sessionEndTime = Date.now() + (limitVal * 60000); useSessionEnd = true; } else { targetCycles = limitVal; useCycleLimit = true; } }

            const statsEl = document.getElementById('neshima-stats');
            statsEl.style.display = 'flex'; 
            if (!useSessionEnd && !useCycleLimit) { statsEl.style.justifyContent = 'center'; statRemaining.style.display = 'none'; } 
            else { statsEl.style.justifyContent = 'space-between'; statRemaining.style.display = 'block'; } 
            updateNeshimaHUD();
            
            requestWakeLock(); toggleSwitcherVisibility(true); neshimaControls.style.display = 'none'; neshimaTimerVisual.style.display = 'block'; 
            neshimaStopBtn.style.display = 'block'; neshimaStopBtn.innerText = "Stop"; neshimaPostBtn.style.display = 'none';
            isNeshimaRunning = true; isBlueBackground = true; document.body.style.backgroundColor = COLOR_BLUE; 
            
            pendingDisplayVal = ""; neshimaLastDisplayVal = "";
            neshimaSvg.style.transition = "none"; neshimaDisplay.style.transition = "opacity 0.2s ease";
            neshimaRing.style.strokeDasharray = "32 750"; neshimaRing.style.transform = `rotate(0deg)`; 
            
            neshimaDisplay.innerText = isHeadstartOn ? "3" : String(Math.ceil(sequence[0])); 

            if (isNeshimaSoftnoiseOn) startNeshimaSoftnoise();

            setTimeout(async () => {
                if (isHeadstartOn) { for (let i = 3; i > 0; i--) { if (!isNeshimaRunning) return; neshimaUpdateDisplay(i); await delay(1000); } if (!isNeshimaRunning) return; }
                playNeshimaBeep('restart'); currentIndex = 0; stepEndTime = Date.now() + (sequence[0] * 1000); neshimaEngineInterval = setInterval(neshimaRunEngine, 16);
            }, 70);
        });

        neshimaStopBtn.addEventListener('click', neshimaStopTimer);

        // --- THE POST-SESSION CINEMATIC ENGINE ---
        let cinematicInterval; let cinematicIndex = 0; let cinematicPhaseEndTime = 0; let globalResetListener = null;
        const cinematicPhases = [
            { type: 'setup', text: "take a<br>deep one in", duration: 2500 },
            { type: 'inhale', text: "6s<br>inhale", duration: 6000 },
            { type: 'hold-high', text: "hold<br>for 15s", duration: 15000 },
            { type: 'exhale', text: "release<br>slowly", duration: 10000 },
            { type: 'hold-low', text: "hold<br>for 30s", duration: 30000 }
        ];

        neshimaPostBtn.addEventListener('click', () => {
            neshimaPostBtn.style.display = 'none'; 
            neshimaStopBtn.style.display = 'block'; 
            neshimaStopBtn.innerText = "Stop"; 
            
            isNeshimaRunning = false; isPostSessionRunning = true;
            neshimaSvg.style.transition = "none";
            neshimaDisplay.style.transition = "opacity 0.2s ease";

            if (isNeshimaSoftnoiseOn && !neshimaNoiseSource) startNeshimaSoftnoise();

            cinematicIndex = 0; cinematicPhaseEndTime = Date.now() + cinematicPhases[0].duration;
            isBlueBackground = true; document.body.style.backgroundColor = COLOR_BLUE;
            cinematicInterval = setInterval(runCinematicEngine, 16);
        });

        function runCinematicEngine() {
            if (!isPostSessionRunning) return;
            const now = Date.now(); let timeLeft = cinematicPhaseEndTime - now; let phase = cinematicPhases[cinematicIndex];

            if (timeLeft <= 0) {
                cinematicIndex++;
                if (cinematicIndex >= cinematicPhases.length) { endCinematicSequence(); return; }
                phase = cinematicPhases[cinematicIndex]; timeLeft = phase.duration; cinematicPhaseEndTime = now + timeLeft;
                if (phase.type !== 'setup') {
                    playNeshimaBeep('step'); isBlueBackground = !isBlueBackground; document.body.style.backgroundColor = isBlueBackground ? COLOR_BLUE : COLOR_GREEN;
                }
            }

            const percentage = Math.max(0, timeLeft) / phase.duration; const progress = 1 - percentage;
            
            if (phase.type !== 'setup') neshimaRing.style.transform = `rotate(${-(percentage * 360)}deg)`;

            const timeElapsed = phase.duration - timeLeft;
            const isText = phase.type === 'setup' || timeElapsed < 3000;
            const displayStr = isText ? phase.text : String(Math.ceil(timeLeft / 1000));
            neshimaUpdateDisplay(displayStr, true);

            const maxRingScale = 1.15; const minRingScale = 0.88; const maxTextScale = 1.08; const minTextScale = 0.92; let ringScale = 1, textScale = 1;
            if (phase.type === 'setup') { 
                ringScale = 1 - (progress * (1 - minRingScale)); 
                textScale = 1 - (progress * (1 - minTextScale)); 
            }
            else if (phase.type === 'inhale') { ringScale = minRingScale + (progress * (maxRingScale - minRingScale)); textScale = minTextScale + (progress * (maxTextScale - minTextScale)); } 
            else if (phase.type === 'exhale') { ringScale = maxRingScale - (progress * (maxRingScale - minRingScale)); textScale = maxTextScale - (progress * (maxTextScale - minTextScale)); } 
            else if (phase.type === 'hold-high') { ringScale = maxRingScale; textScale = maxTextScale; } 
            else if (phase.type === 'hold-low') { ringScale = minRingScale; textScale = minTextScale; }
            
            window.lastNeshimaTextScale = textScale;
            neshimaSvg.style.transform = `rotate(-90deg) scale(${ringScale})`; neshimaDisplay.style.transform = `scale(${textScale})`;

            if (isNeshimaSoftnoiseOn && neshimaNoiseFilter) {
                const minFreq = 250; const maxFreq = 800; const minVol = 0.02; const maxVol = 0.1; let currentFreq = minFreq; let currentVol = minVol;
                if (phase.type === 'setup') { currentFreq = minFreq; currentVol = minVol; }
                else if (phase.type === 'inhale') { currentFreq = minFreq + (progress * (maxFreq - minFreq)); currentVol = minVol + (progress * (maxVol - minVol)); } 
                else if (phase.type === 'exhale') { currentFreq = maxFreq - (progress * (maxFreq - minFreq)); currentVol = maxVol - (progress * (maxVol - minVol)); } 
                else if (phase.type === 'hold-high') { currentFreq = maxFreq; currentVol = maxVol; } 
                else if (phase.type === 'hold-low') { currentFreq = minFreq; currentVol = minVol; }
                neshimaNoiseFilter.frequency.setTargetAtTime(currentFreq, audioCtx.currentTime, 0.03); neshimaNoiseGain.gain.setTargetAtTime(currentVol, audioCtx.currentTime, 0.03);
            }
        }

        function endCinematicSequence() {
            isPostSessionRunning = false; clearInterval(cinematicInterval); playCompletionChime(); stopNeshimaSoftnoise();
            
            neshimaRing.style.transform = `rotate(0deg)`; neshimaRing.style.strokeDasharray = "0 750"; 
            neshimaStopBtn.style.display = 'none'; 

            neshimaSvg.style.transition = "transform 2s ease-in-out"; 
            neshimaDisplay.style.transition = "transform 2s ease-in-out, opacity 0.2s ease";
            neshimaSvg.style.transform = `rotate(-90deg) scale(1)`; 
            window.lastNeshimaTextScale = 1; neshimaDisplay.style.transform = `scale(1)`;
            
            neshimaUpdateDisplay("Finish", true);
            
            setTimeout(() => {
                globalResetListener = () => { document.removeEventListener('click', globalResetListener); globalResetListener = null; neshimaStopTimer(); };
                document.addEventListener('click', globalResetListener);
            }, 300); 
        }
    </script>
</body>
</html>